# 3주차 Front-End

## 튜터링

`흔히 말하는 웹페이지가 느리다. 라는 말들의 원인들`

* 첫번째. 로딩이 느리다.
* 두번째. 인터랙션이 느리다.

`여기서 말하는 인터랙션의 종류는 예를들면`

* Flicking Slider가 움직일때에 버벅 거려요.
* 스크롤 할때에 버벅 거려요.

### 왜 이런 문제가 발생하는 것인가 ?

사실 브라우저의 버그가 아니고서야.. 인터렉션의 문제들은 DOM과 관련이 있다. 
한마디로 DOM handling을 잘못하고있다는 것이다.

### 그러면 어떻게 해결 할 수 있나요 ?

DOM handlding 문제라면, 간단하다 DOM을 최대한 적게 터치해야 한다.
최대한 적게 컨트롤해야 한다는 것이다.

코드로 예를 들면,

```javascript
// aJax 콜백 성공 함수 
success : function(res) {
    for(var i = 0; i < res.length; i++) {
        $list.append('<li>' + res.id + '</li>');
    }
}
```
위와 같은 코드는 아무 문제 없이 잘 작동할 것이다.
`다만, for loop을 통해서 $.append 메서드를 계속해서 호출한다는 것이다.`
append함수를 계속 호출 하는 것은 그닥 바람직 하지 않다. 내부의 로직이 계속 수행되야만 하기 때문이다. 데이터가 늘어날 수록 성능면에서는 좋지 않을 것이다.


위 코드를 한번 다시 바꿔보자.
```javascript
// aJax 콜백 성공 함수 
success : function(res) {
    var result = [];
    for(var i = 0; i < res.length; i++) {
        result.push('<li>' + res.id + '</li>');
    }
    $list.html(result);
}
```
`append()`를 for loop 동안 계속 호출하지 않는 대신에, result[] 배열에 결과를 계속 추가하여 `html()`를 한번만 호출하여 동일한 결과값을 얻을 수 있다. 하지만 이 방법은 `result[]` 배열을 할당해야 한다는 단점이 있다.

위 코드를 다시 한번 개선해 보자.

```javascript
// aJax 콜백 성공 함수 
success : function(res) {
    $list.html(
        res.map(function(result, i) {
            return '<li>' + result.id + '</li>';
        }).join('')
    );
}
```

다음과 같은 코드로 변경 할 수 있다. `map()` 함수는 배열을 순회하면서 `callback()` 내부의 로직을 수행하면서 기존 배열과는 다른 배열을 새롭게 리턴한다. 

```javascript
var double = [1,2,3].map(function(item, i) {
    return item * 2;
})

console.log(double) // [2,4,6]
```

### 결론

* 인터렉션 문제는 DOM 컨트롤 문제일 가능성이 높다
* 때문에 DOM을 최대한 `적게` 건드리면서 컨트롤 하는것이 바람직하다.
* 위 예제들 처럼 `append()`를 매번 하는 것 보다 `html()`을 한번만 호출 하는 것이 좋고, `map()`을 통해서 arr 변수를 할당하지 않고 새로운 배열을 리턴하면서 데이터를 추가하는 방법도 알아봤다. 더 나아가서 `filter()`, `reduce()` 와 같은 것들도 배우면 좋을 것 같다.


또, `확장성 있는 모듈을 만들고 싶을때에` 모듈의 어떠한 값이 변경되거나 DOM을 컨트롤 할때에는, 컨트롤 할 대상의 Container Element 즉, BASE가 되는 ELEMENT를 받는 것이 좋다. `왜냐하면 ? 변경될 여지가 많은 것이기 때문` 때문에, `변화가 많은 것들을 밖으로 빼고` `변하지 않는 것을 안으로 넣는다`. 응집도(코드) 결합도(인스턴스) 응집도는 높고 결합도는 낮아야 한다. 핵심포인트. 변화하는 것을 잘 캐치해야 해서 잘 분리해야 한다.


### 마우스 이벤트들

* mouseover, mouseout
    - 이 두가지의 Event들은 `<element></element>` 단위로 작동한다.
    - 현재 타겟팅과 계속해서 비교하기 때문에, `<elem><h2></h2><h3></h3></elem>`와 같이 자식노드에 포함된 `<h2></h2>`와 `<h3></h3>`에 영향을 미치게 된다.
    - 이를 해결하기 위해서 jQuery는 **mouseenter, mouseleave**를 개발
* mousenter, mouseleave
    - 이 두가지 Event들은 `<elem></elem>의 영역!` 단위로 작동한다.
    - `<elem></elem>`의 영억으로 제한되기 때문에, 이벤트가 전파되거나 하지 않아서 자식 엘리먼트에 영향을 주지 않게 되었다.


## 멘토링

* 이벤트가 진행되는 도중에 중간에서 상태의 변화가 생길 수 있는 여지를 주지 말자.
    - javascript 코딩을 하면서 많이 실수하는 부분 중 하나.
    - 이벤트가 반드시 한번만 진행될 것이라는 보장이 없을 경우에

* 강제되지 않는 제약이 없다면, 항상 가능성을 열고 코딩을 하는 것이 좋다.
    - 확장성 있는 코드를 연습해야 될 것 같다.

* 자바스크립트에서는 스택영역이 없다.
    - 없지만, 콜스택 영역은 있다 (함수 호출 스택)
    - 왜 없는 것인가? 
        - 메모리영역에 대한 이슈. ( 정확하게 계산 할 수 없다 ) 스택 영역은 정확하게 메모리가 계산이 되어서 그 부분을 할당할 수 있게 해주는 역할인데, 
        - 정확히는 스코프 체이닝이 일어나면, 메모리에서 해제되지 않기 때문에, 메모리 영역을 계산 할 수 없게된다. 그래서 힙 영역에 할당이 되는 것이다.

### for() vs forEach() vs map()

* 함수는 무조건 메모리에 올라갈 수 밖에 없기 때문에 기본적으로 for()문이 성능이 가장 좋다.
* 대신에, `map()` 함수는 사이드 이펙트를 미치지 않는 점에서 장점이 좋다.

### 모듈을 작성할 때에 가장 중요하게 생각해야 할 점
* 1. 제어의 역전이 일어나면 안된다.
* 2. 모듈들의 순환구조가 이루어 지면 안된다.. (A -> B, B -> C, C -> A)
* 3. 응집성은 높아야 하고, 결합도가 낮아야 한다.
* 4. [함수 네이밍] 함수네이밍이 안에서 하는 것이 이름이 되는 것이 아니라, 결과적으로 어떤것을 위한 행위인지에 대한 정확한 네이밍이 필요하다.